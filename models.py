"""
MeshSOS Data Models
Schema Version: v1

Canonical message schema shared across:
- ESP32 node firmware
- Gateway bridge
- Backend API
- Dashboard and mobile app
"""

from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field, field_validator


SCHEMA_VERSION = "v1"


class MessageType(str, Enum):
    """Types of messages supported by MeshSOS"""
    SOS = "sos"
    SUPPLY_REQUEST = "supply_request"
    STATUS_UPDATE = "status_update"
    BROADCAST = "broadcast"


class MeshMessageModel(BaseModel):
    """
    Core message model for MeshSOS network.
    
    All messages flowing through the system (LoRa → Gateway → Backend → Dashboard)
    must conform to this schema.
    """
    node_id: str = Field(..., min_length=1, max_length=32, description="Unique node identifier")
    timestamp: int = Field(..., gt=0, description="Unix epoch timestamp (seconds)")
    message_type: MessageType
    urgency: int = Field(..., ge=1, le=3, description="Urgency level: 1=low, 2=medium, 3=high")
    
    # Optional location data (coarse GNSS)
    lat: Optional[float] = Field(None, ge=-90, le=90, description="Latitude")
    lon: Optional[float] = Field(None, ge=-180, le=180, description="Longitude")
    
    # Optional supply/resource data
    resource_type: Optional[str] = Field(None, max_length=32, description="Type of resource (water, food, medical, etc.)")
    quantity: Optional[int] = Field(None, ge=0, le=10000, description="Quantity or number of items")
    
    # Optional free-text payload
    payload: Optional[str] = Field(None, max_length=100, description="Additional message content")
    
    @field_validator('payload')
    @classmethod
    def validate_payload_length(cls, v):
        """Ensure payload stays within LoRa bandwidth constraints"""
        if v and len(v.encode('utf-8')) > 100:
            raise ValueError("Payload too large for LoRa transmission (max 100 bytes)")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "node_id": "node-001",
                "timestamp": 1733184000,
                "message_type": "supply_request",
                "urgency": 3,
                "lat": 43.4723,
                "lon": -80.5449,
                "resource_type": "water",
                "quantity": 10,
                "payload": "Urgent: community shelter needs water"
            }
        }


class MessageOut(BaseModel):
    """API response model including database ID"""
    id: int
    node_id: str
    timestamp: int
    message_type: str
    urgency: int
    lat: Optional[float] = None
    lon: Optional[float] = None
    resource_type: Optional[str] = None
    quantity: Optional[int] = None
    payload: Optional[str] = None


class NodeStatus(BaseModel):
    """Derived view of latest status per node"""
    node_id: str
    last_seen: int
    last_message_type: str
    last_urgency: int
    last_lat: Optional[float] = None
    last_lon: Optional[float] = None
    message_count: int


class RoutePlan(BaseModel):
    """Route plan generated by routing engine"""
    id: Optional[int] = None
    created_at: Optional[int] = None
    mode: str = Field(..., description="Route mode: distance, priority, or blended")
    depot_lat: float
    depot_lon: float
    stops: list[dict]  # List of {lat, lon, node_id, resource_type, quantity, urgency}
    total_distance_km: float
    estimated_time_minutes: float
    urgent_requests_served: int
    metadata: Optional[dict] = None
